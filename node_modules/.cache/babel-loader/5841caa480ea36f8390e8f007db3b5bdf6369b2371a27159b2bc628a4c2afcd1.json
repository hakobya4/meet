{"ast":null,"code":"import _slicedToArray from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/karenhakobyan/Desktop/meet/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nvar PrecacheStrategy = /*#__PURE__*/function (_Strategy, _handle2, _handleFetch2, _handleInstall2) {\n  _inherits(PrecacheStrategy, _Strategy);\n  var _super = _createSuper(PrecacheStrategy);\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  function PrecacheStrategy() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, PrecacheStrategy);\n    options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n    _this = _super.call(this, options);\n    _this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n    // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n    _this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    return _this;\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  _createClass(PrecacheStrategy, [{\n    key: \"_handle\",\n    value: function _handle(_x, _x2) {\n      return (_handle2 = _handle2 || _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, handler) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return handler.cacheMatch(request);\n            case 2:\n              response = _context.sent;\n              if (!response) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\", response);\n            case 5:\n              if (!(handler.event && handler.event.type === 'install')) {\n                _context.next = 9;\n                break;\n              }\n              _context.next = 8;\n              return this._handleInstall(request, handler);\n            case 8:\n              return _context.abrupt(\"return\", _context.sent);\n            case 9:\n              _context.next = 11;\n              return this._handleFetch(request, handler);\n            case 11:\n              return _context.abrupt(\"return\", _context.sent);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }))).apply(this, arguments);\n    }\n  }, {\n    key: \"_handleFetch\",\n    value: function _handleFetch(_x3, _x4) {\n      return (_handleFetch2 = _handleFetch2 || _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, handler) {\n        var response, params, integrityInManifest, integrityInRequest, noIntegrityConflict, wasCached, cacheKey;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              params = handler.params || {}; // Fall back to the network if we're configured to do so.\n              if (!this._fallbackToNetwork) {\n                _context2.next = 17;\n                break;\n              }\n              if (process.env.NODE_ENV !== 'production') {\n                logger.warn(\"The precached response for \" + \"\".concat(getFriendlyURL(request.url), \" in \").concat(this.cacheName, \" was not \") + \"found. Falling back to the network.\");\n              }\n              integrityInManifest = params.integrity;\n              integrityInRequest = request.integrity;\n              noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest; // Do not add integrity if the original request is no-cors\n              // See https://github.com/GoogleChrome/workbox/issues/3096\n              _context2.next = 8;\n              return handler.fetch(new Request(request, {\n                integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n              }));\n            case 8:\n              response = _context2.sent;\n              if (!(integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors')) {\n                _context2.next = 15;\n                break;\n              }\n              this._useDefaultCacheabilityPluginIfNeeded();\n              _context2.next = 13;\n              return handler.cachePut(request, response.clone());\n            case 13:\n              wasCached = _context2.sent;\n              if (process.env.NODE_ENV !== 'production') {\n                if (wasCached) {\n                  logger.log(\"A response for \".concat(getFriendlyURL(request.url), \" \") + \"was used to \\\"repair\\\" the precache.\");\n                }\n              }\n            case 15:\n              _context2.next = 18;\n              break;\n            case 17:\n              throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url\n              });\n            case 18:\n              if (!(process.env.NODE_ENV !== 'production')) {\n                _context2.next = 34;\n                break;\n              }\n              _context2.t0 = params.cacheKey;\n              if (_context2.t0) {\n                _context2.next = 24;\n                break;\n              }\n              _context2.next = 23;\n              return handler.getCacheKey(request, 'read');\n            case 23:\n              _context2.t0 = _context2.sent;\n            case 24:\n              cacheKey = _context2.t0;\n              // Workbox is going to handle the route.\n              // print the routing details to the console.\n              logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(request.url));\n              logger.log(\"Serving the precached url: \".concat(getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)));\n              logger.groupCollapsed(\"View request details here.\");\n              logger.log(request);\n              logger.groupEnd();\n              logger.groupCollapsed(\"View response details here.\");\n              logger.log(response);\n              logger.groupEnd();\n              logger.groupEnd();\n            case 34:\n              return _context2.abrupt(\"return\", response);\n            case 35:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }))).apply(this, arguments);\n    }\n  }, {\n    key: \"_handleInstall\",\n    value: function _handleInstall(_x5, _x6) {\n      return (_handleInstall2 = _handleInstall2 || _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request, handler) {\n        var response, wasCached;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              this._useDefaultCacheabilityPluginIfNeeded();\n              _context3.next = 3;\n              return handler.fetch(request);\n            case 3:\n              response = _context3.sent;\n              _context3.next = 6;\n              return handler.cachePut(request, response.clone());\n            case 6:\n              wasCached = _context3.sent;\n              if (wasCached) {\n                _context3.next = 9;\n                break;\n              }\n              throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status\n              });\n            case 9:\n              return _context3.abrupt(\"return\", response);\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }))).apply(this, arguments);\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n  }, {\n    key: \"_useDefaultCacheabilityPluginIfNeeded\",\n    value: function _useDefaultCacheabilityPluginIfNeeded() {\n      var defaultPluginIndex = null;\n      var cacheWillUpdatePluginCount = 0;\n      var _iterator = _createForOfIteratorHelper(this.plugins.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            index = _step$value[0],\n            plugin = _step$value[1];\n          // Ignore the copy redirected plugin when determining what to do.\n          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n            continue;\n          }\n          // Save the default plugin's index, in case it needs to be removed.\n          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n            defaultPluginIndex = index;\n          }\n          if (plugin.cacheWillUpdate) {\n            cacheWillUpdatePluginCount++;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (cacheWillUpdatePluginCount === 0) {\n        this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n      } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n        // Only remove the default plugin; multiple custom plugins are allowed.\n        this.plugins.splice(defaultPluginIndex, 1);\n      }\n      // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n  }]);\n  return PrecacheStrategy;\n}(Strategy);\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n  cacheWillUpdate: function cacheWillUpdate(_ref) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var response;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            response = _ref.response;\n            if (!(!response || response.status >= 400)) {\n              _context4.next = 3;\n              break;\n            }\n            return _context4.abrupt(\"return\", null);\n          case 3:\n            return _context4.abrupt(\"return\", response);\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n  cacheWillUpdate: function cacheWillUpdate(_ref2) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      var response;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            response = _ref2.response;\n            if (!response.redirected) {\n              _context5.next = 7;\n              break;\n            }\n            _context5.next = 4;\n            return copyResponse(response);\n          case 4:\n            _context5.t0 = _context5.sent;\n            _context5.next = 8;\n            break;\n          case 7:\n            _context5.t0 = response;\n          case 8:\n            return _context5.abrupt(\"return\", _context5.t0);\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n};\nexport { PrecacheStrategy };","map":{"version":3,"names":["copyResponse","cacheNames","getFriendlyURL","logger","WorkboxError","Strategy","PrecacheStrategy","_Strategy","_handle2","_handleFetch2","_handleInstall2","_inherits","_super","_createSuper","_this","options","arguments","length","undefined","_classCallCheck","cacheName","getPrecacheName","call","_fallbackToNetwork","fallbackToNetwork","plugins","push","copyRedirectedCacheableResponsesPlugin","_createClass","key","value","_handle","_x","_x2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","request","handler","response","wrap","_callee$","_context","prev","next","cacheMatch","sent","abrupt","event","type","_handleInstall","_handleFetch","stop","apply","_x3","_x4","_callee2","params","integrityInManifest","integrityInRequest","noIntegrityConflict","wasCached","cacheKey","_callee2$","_context2","process","env","NODE_ENV","warn","concat","url","integrity","fetch","Request","mode","_useDefaultCacheabilityPluginIfNeeded","cachePut","clone","log","t0","getCacheKey","groupCollapsed","groupEnd","_x5","_x6","_callee3","_callee3$","_context3","status","defaultPluginIndex","cacheWillUpdatePluginCount","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","index","plugin","defaultPrecacheCacheabilityPlugin","cacheWillUpdate","err","e","f","splice","_ref","_callee4","_callee4$","_context4","_ref2","_callee5","_callee5$","_context5","redirected"],"sources":["/Users/karenhakobyan/Desktop/meet/node_modules/workbox-precaching/PrecacheStrategy.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork =\n            options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n            return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = (handler.params || {});\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            // Do not add integrity if the original request is no-cors\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== 'no-cors'\n                    ? integrityInRequest || integrityInManifest\n                    : undefined,\n            }));\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n            // that the response matches the precache manifest's expectations,\n            // and there's either a) no integrity property in the incoming request\n            // or b) there is an integrity, and it matches the precache manifest.\n            // See https://github.com/GoogleChrome/workbox/issues/2858\n            // Also if the original request users no-cors we don't use integrity.\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            if (integrityInManifest &&\n                noIntegrityConflict &&\n                request.mode !== 'no-cors') {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\n                            `was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n            // Ignore the copy redirected plugin when determining what to do.\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            // Save the default plugin's index, in case it needs to be removed.\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        }\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            // Only remove the default plugin; multiple custom plugins are allowed.\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n    async cacheWillUpdate({ response }) {\n        if (!response || response.status >= 400) {\n            return null;\n        }\n        return response;\n    },\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    },\n};\nexport { PrecacheStrategy };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}